# 20240827
# 22:00
# 1 / 1

"""
풀이 시간: 22분 (15:00 ~ 15:22)
풀이 시도: 1 / 1


1. 문제 정독 & 풀이 구상 (15:00 - 15:07)
    주어진 테트로미노 모양 중, 최대값 가지는 하나만을 대보는 것이기에
    해당 문제는 완전탐색으로 풀어도 되겠다는 생각이 들었습니다.

    핵심은 대칭/회전이 가능하다는 점인데,
    해당 대칭/회전에 대한 규칙을 찾아내서, 반영할 수도 있다는 생각이 들었습니다.
    그러나, 어제의 '주사위 굴리기' 문제에서 과도한 규칙성에 대한 집착으로 시간이 많이 소모됐음이 기억났기에,
    하드코딩하더라도 이 풀이에 확신이 들었기에, 모든 대칭/회전을 수작업으로 해주기로 결정했습니다.


2. 구현 (15:07 - 15:18)
    테트로미노(tetrominos) 튜플을 구성할 때, 해당 좌표들이 하나라도 틀리면 안 되기에,
    메모의 그림과 비교하며, 실수 없이 적도록 신중을 기했습니다.


3. 검증 (15:18 - 15:22)
    모든 좌표에서 19개의 테트로미노 모양(3개씩 다음 좌표 들어있음)을 완전탐색하는 것에,
    시간복잡도를 계산했을 때는 이상이 없었지만, 최대치에 대한 시간 검증을 하고자 했습니다.
    따라서 N,M이 500,500인 테스트케이스를 만들었고, 정상적인 시간 내에 정답을 출력했습니다.

    그리고, tetrominos에 적혀있는 좌표가 하나라도 틀리면 안 되기에,
    2번씩 초기 메모에 적힌 대칭/회전 케이스들과 비교하며 점검했습니다.
"""

tetrominos = (
    ((0, 1), (0, 2), (0, 3)), ((1, 0), (2, 0), (3, 0)),
    ((1, 0), (0, 1), (1, 1)),
    ((0, 1), (0, 2), (1, 2)), ((0, 1), (0, 2), (-1, 2)), ((1, 0), (2, 0), (2, 1)), ((1, 0), (2, 0), (2, -1)), ((-1, 0), (-2, 0), (-2, 1)), ((-1, 0), (-2, 0), (-2, -1)), ((0, -1), (0, -2), (1, -2)), ((0, -1), (0, -2), (-1, -2)),
    ((0, 1), (-1, 1), (-1, 2)), ((0, 1), (1, 1), (1, 2)), ((1, 0), (1, 1), (2, 1)), ((1, 0), (1, -1), (2, -1)),
    ((-1, -1), (-1, 0), (-1, 1)), ((1, -1), (1, 0), (1, 1)), ((-1, 1), (0, 1), (1, 1)), ((-1, -1), (0, -1), (1, -1))
)
"""
위의 각 줄은 5개의 폴리오미노 모양에 대한 대칭/회전 케이스를 전부 다뤄준 것입니다.

ㅁㅁㅁㅁ     ㅁㅁ     ㅁ       ㅁ        ㅁ
           ㅁㅁ     ㅁ       ㅁㅁ       ㅁㅁ
                   ㅁㅁ       ㅁ       ㅁ

위 순서대로 줄바꿈되어 있습니다.
"""


def oob(y, x):
    return y < 0 or n <= y or x < 0 or m <= x


def check_possible_tetrominos(y, x):  # 인자로 들어온 좌표를 시작으로 모든 테트로미노 대보고, 최대값을 갱신하는 함수
    for tetromino in tetrominos:
        tmp_answer = area[y][x]  # tetromino가 현재 값 기준으로 다른 좌표 3개로 구성돼 있기에, 초기값은 현재 좌표의 값으로 설정해야 함.
        for dy, dx in tetromino:
            ny, nx = y + dy, x + dx
            if oob(ny, nx):  # 영역 밖으로 하나라도 벗어난다면 break
                break
            tmp_answer += area[ny][nx]  # 현재 테트로미노의 가능한 좌표라면, 그 값 추가
        else:  # 하나라도 영역 밖으로 벗어나지 않았어야, 놓을 수 있는 테트로미노가 됨
            global mx_answer
            mx_answer = max(mx_answer, tmp_answer)  # 최대값 갱신


n, m = map(int, input().split())
area = [list(map(int, input().split())) for _ in range(n)]

mx_answer = 0

for i in range(n):
    for j in range(m):  # 모든 좌표에 대해
        check_possible_tetrominos(i, j)  # 모든 테트로미노 대보고, 최대값 갱신

print(mx_answer)
